<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 5 | Whellote</title>

  
  <meta name="author" content="whellote">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Whellote"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whellote" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Whellote</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/js禁止鼠标右键/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/js禁止鼠标右键/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.565Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>#js禁止鼠标右键</p>
<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    $(<span class="built_in">document</span>).bind(<span class="string">"contextmenu"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;   </span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span>&gt;</span><br><span class="line">     <span class="built_in">document</span>.oncontextmenu=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"event.returnValue=false;"</span>);</span><br><span class="line">     <span class="built_in">document</span>.onselectstart=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"event.returnValue=false;"</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>##禁止右键弹出的突破方法<br>地址栏中输入：<code>javascript:alert($(document).unbind(&quot;contextmenu&quot;,&quot;&quot;));</code></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/java培训笔记/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/java培训笔记/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.551Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型-java内存-堆栈"><a href="#数据类型-java内存-堆栈" class="headerlink" title="数据类型(java内存 堆栈)"></a>数据类型(java内存 堆栈)</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><blockquote>
<p>引用数据类型</p>
</blockquote>
<p>`</p>
<blockquote>
<p>java内存 堆栈</p>
</blockquote>
<p><code>int</code>与<code>double</code> 用的比较多</p>
<blockquote>
<p><code>id</code> 一般用 <code>long</code></p>
</blockquote>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><h3 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h3><table><br><br>    <tr><br>        <td>class</td><br>        <td>类名和文件名时一致的</td><br>    </tr><br><br>    <tr><br>        <td>native</td><br>        <td>本地, 原生方法(非java语言)</td><br>    </tr><br>    <tr><br>        <td>static</td><br>        <td><br>            1. 不用new对象<br>            2. 内存<br>        </td><br>    </tr><br>    <tr><br>        <td>synchronized</td><br>        <td>线程, 一个对象调用该对象时, 其他的对象不能再调用</td><br>        <td>缺点: 不能并发, 效率低, 并发效果低</td><br>    </tr><br>    <tr><br>        <td>transient</td><br>        <td>线程高并发相关</td><br>    </tr><br><br></table>

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="私有构造方法"><a href="#私有构造方法" class="headerlink" title="私有构造方法"></a>私有构造方法</h4><p>单例模式: 一般IO流</p>
<h4 id="公有构造方法"><a href="#公有构造方法" class="headerlink" title="公有构造方法"></a>公有构造方法</h4><ul>
<li>无参构造方法</li>
<li>有参构造方法</li>
</ul>
<p>`</p>
<h5 id="方法的重载和重写"><a href="#方法的重载和重写" class="headerlink" title="方法的重载和重写"></a>方法的重载和重写</h5><blockquote>
<p>重载: 方法名一样, 参数不同(参数的个数, 参数的类型)</p>
</blockquote>
<blockquote>
<p>重写: 重写父类的方法, 方法名, 参数一样.</p>
</blockquote>
<p>`</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p><code>int</code>与<code>Integer</code></p>
<ul>
<li>int有默认值, 包装类没有默认值</li>
<li>包装类有方法有属性</li>
<li>比较大小<pre><code>&lt;pre&gt;`i.equals(args0)`&lt;/pre&gt;
</code></pre></li>
<li>转换  <pre>Integer.valueOf(s)</pre>


</li>
</ul>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>List (序列)</li>
<li>Map (键值对)</li>
<li>Set (不知道Map里的键名情况下-遍历map)</li>
</ul>
<blockquote>
<p>HashMap 非线程安全, 性能较高</p>
</blockquote>
<blockquote>
<p>HashTable 线程安全, 性能效率低</p>
</blockquote>
<pre><code>Map&lt;String, String&gt; map = new HashMap&lt;String&gt;&lt;String&gt;();
map.put(&quot;username&quot;, &quot;szg&quot;);
</code></pre><blockquote>
<p>如果不使用泛型: 在<code>map.put(&quot;username&quot;, &quot;szg&quot;);</code>部分进行强制类型转换也行, 但不推荐</p>
</blockquote>
<pre><code>Set s = map.keySet();
</code></pre><p>循环set</p>
<pre><code>for(String str : s) {

}
</code></pre><p>遍历list </p>
<pre>
for(int i = 0; i < list.size(); i++) {}
</pre>


<pre><code>List&lt;String&gt; list
    for (String[] s : list) {

} 
</code></pre><blockquote>
<p>第二种方法效率相对高</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/java判断两个long类型相等/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/java判断两个long类型相等/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.547Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> baseTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDataStructer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Long l1 = <span class="number">10000026500083l</span>;</span><br><span class="line">		Long l2 = <span class="number">10000026500083l</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>  (l1 == l2 ) &#123;</span><br><span class="line">			System.out.println(<span class="string">"== "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (l1.equals(l2)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"equals"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (l1.longValue() == l2.longValue()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"longValue"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输出结果是:<br>equals<br>longValue</p>
</blockquote>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/java里的main方法/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/java里的main方法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.542Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java里的main方法"><a href="#java里的main方法" class="headerlink" title="java里的main方法"></a>java里的main方法</h1><ul>
<li><p>形式<br>public static void main(String[] args){ }<br>public static void main(String args[]){ }</p>
<p>String[] args可以写成String args[]，以及args的名称可以改变外</p>
</li>
<li><p>eclips快速创建<br>输入<code>main</code>，在按住<code>Alt+/</code>的方式快速创建main方法。</p>
</li>
<li><p>static的定义是为了JVM在调用main方法时不用实例化对象，只需要在初始时加载main方法所在类，然后直接通过类名.main来调用main方法。</p>
</li>
<li>main的名称不能变是为了JVM能够识别程序运行的起点，main方法可以被重载，重载的main方法不会被执行。</li>
<li>非守护线程</li>
<li>main()方法中可以throw Exception</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/java-基础-集合框架/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/java-基础-集合框架/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.534Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java-基础-集合框架"><a href="#java-基础-集合框架" class="headerlink" title="java-基础-集合框架"></a>java-基础-集合框架</h1><h2 id="集合框架定义的接口"><a href="#集合框架定义的接口" class="headerlink" title="集合框架定义的接口"></a>集合框架定义的接口</h2><ul>
<li>Collection</li>
<li>List</li>
<li>Set</li>
<li>SortedSet</li>
<li>Map</li>
<li>Map.Entry</li>
<li>SortedMap</li>
<li>Enumeration</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>继承于Collection和一个 List实例存储一个有序集合的元素。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>继承于 Collection，是一个不包含重复元素的集合。</li>
</ul>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><ul>
<li>继承于Set保存有序的集合。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>将唯一的键映射到值。</li>
</ul>
<h3 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h3><ul>
<li>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</li>
<li>由Map接口中声明的entrySet()方法返回一个包含映射条目的集。每个组元素都是一个Map.Entry对象。</li>
</ul>
<h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><ul>
<li>继承于Map，使Key保持在升序排列。</li>
</ul>
<h3 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h3><ul>
<li>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/java-基础-Vector与ArrayList区别/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/java-基础-Vector与ArrayList区别/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.519Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java-基础-Vector与ArrayList区别"><a href="#java-基础-Vector与ArrayList区别" class="headerlink" title="java-基础-Vector与ArrayList区别"></a>java-基础-Vector与ArrayList区别</h1><h2 id="List接口的三个实现类"><a href="#List接口的三个实现类" class="headerlink" title="List接口的三个实现类"></a>List接口的三个实现类</h2><ul>
<li>ArrayList</li>
<li>Vector</li>
<li>LinkedList</li>
</ul>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li>通过数组实现</li>
<li>缺点: 每个元素之间不能有间隔</li>
<li>存储空间扩容时需要将数据复制</li>
<li>能快速随机访问和遍历</li>
<li>不便于插入和删除</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li>通过数组实现</li>
<li>支持线程同步(某一时刻只有一个线程能够写Vector)</li>
<li>访问比ArrayList慢</li>
<li>包含许多传统的方法, 这些方法不属于集合框架</li>
<li>主要用在事先不知道数组的大小, 或者只是需要一个可以改变大小的数组的情况</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li>链表</li>
<li>适合动态插入和删除</li>
<li>随机访问和遍历比较慢</li>
<li>具有List没有定义的方法: 操作表头和表尾元素</li>
<li>可以当做堆栈, 队列, 双向队列使用</li>
</ul>
<h2 id="超过长度时增长率"><a href="#超过长度时增长率" class="headerlink" title="超过长度时增长率"></a>超过长度时增长率</h2><p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zhangzongle/p/5432212.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangzongle/p/5432212.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/java堆栈/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/java堆栈/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.506Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java堆栈"><a href="#java堆栈" class="headerlink" title="java堆栈"></a>java堆栈</h1><p>JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：</p>
<ol>
<li>寄存器</li>
<li>本地方法区</li>
<li>方法区</li>
<li>栈</li>
<li>堆</li>
</ol>
<h2 id="通用编译原理上的内存分配策略"><a href="#通用编译原理上的内存分配策略" class="headerlink" title="通用编译原理上的内存分配策略"></a>通用编译原理上的内存分配策略</h2><ol>
<li>静态</li>
<li>栈式</li>
<li>堆式</li>
</ol>
<h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>编译时就确定存储空间的需求, 因此不允许有可变的无法准确计算存储空间的结构出现(可变数组, 嵌套或递归结构)</p>
<h3 id="栈式"><a href="#栈式" class="headerlink" title="栈式"></a>栈式</h3><ul>
<li>动态存储分配, 但是在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存</li>
<li>用来执行程序的</li>
<li>c/c++所有方法调用都是用栈, 通过指针, 速度最快</li>
<li>数据结构: 先进后出</li>
<li>操作系统: 由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈</li>
<li>缓存方式: 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。</li>
<li>申请影响: 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li>
<li>内存: 有栈顶地址和最大容量的连续的内存空间, 向低地址扩展</li>
</ul>
<h3 id="堆式"><a href="#堆式" class="headerlink" title="堆式"></a>堆式</h3><ul>
<li>堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配, 堆中的内存可以按照任意顺序分配和释放.</li>
<li>用来放对象的</li>
<li>堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间</li>
<li>面向对象的多态性, 堆是必不可少的.</li>
<li>数据结构: 队列优先, 先进先出/ 堆可以被看成是一棵树，如：堆排序。</li>
<li>操作系统: 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</li>
<li>缓存方式: 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</li>
<li>申请影响: 操作系统有一个空闲的内存地址链表, 当程序申请时, 会寻找第一个空间大于申请空间的堆节点分配给程序, 系统会将多余那部分重新放入空闲链表里</li>
<li>内存: 不连续的, 遍历是由低地址向高地址扩展</li>
</ul>
<h2 id="JVM中的堆栈"><a href="#JVM中的堆栈" class="headerlink" title="JVM中的堆栈"></a>JVM中的堆栈</h2><ul>
<li>JVM为每个新创建的线程都分配一个堆栈</li>
<li>堆栈以帧为单位保存线程的状态。</li>
<li>JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</li>
</ul>
<h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><ul>
<li>基础数据类型</li>
<li>局部变量</li>
<li>对象的引用变量</li>
<li>特点: 执行完毕立即释放</li>
</ul>
<h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。</p>
<ul>
<li>new创建的对象和数组。</li>
<li>堆内存中所有的实体都有内存地址值。</li>
<li>堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。</li>
<li>堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除，这也是JAVA优于C++的表现之一（C++中需要程序员手动清除）。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>Car c = new Car(); // 将地址给了c<br>Car c2 = c // c 和 c2 都指向同一个 new Car() 内存地址</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ibelieve618/p/6380328.html" target="_blank" rel="noopener">https://www.cnblogs.com/ibelieve618/p/6380328.html</a><br><a href="http://blog.csdn.net/jerryao/article/details/874101" target="_blank" rel="noopener">http://blog.csdn.net/jerryao/article/details/874101</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/java包装类/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/java包装类/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.497Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java包装类"><a href="#java包装类" class="headerlink" title="java包装类"></a>java包装类</h1><h2 id="包装类简介"><a href="#包装类简介" class="headerlink" title="包装类简介"></a>包装类简介</h2><ul>
<li>为什么会有包装类?<br>  Java中的基本数据类型是不面向对象的, 变量是存在栈中的, 更高效<br>  变量的值存储在栈里，而对象存储在堆里，相比而言，堆栈更高效，这也是java保留基本类型的原因。</li>
<li>除了Integer和Character类以后，其它六个类的类名和基本数据类型一直，只是类名的第一个字母大写即可。<br>  Byte, Boolean, Short, Character, Integer, Long, Float, Double</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol>
<li>作为和基本数据类型对应的类类型存在，方便涉及到对象的操作。</li>
<li>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</li>
</ol>
<h3 id="掌握"><a href="#掌握" class="headerlink" title="掌握"></a>掌握</h3><ol>
<li>包装类与基础数据类型之间的转换</li>
<li>包装类的类型转换(包装类的常用方法)</li>
<li>开发中包装类的常见作用</li>
<li>自动拆装箱</li>
</ol>
<h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><ul>
<li>当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。</li>
<li>equals方法并不会进行类型转换</li>
</ul>
<h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><p>详见:<a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/hjf19790118/article/details/7081925" target="_blank" rel="noopener">http://blog.csdn.net/hjf19790118/article/details/7081925</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/java-Unsupported major.minor version 52.0错误解决-eclipse-jdk配置/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/java-Unsupported major.minor version 52.0错误解决-eclipse-jdk配置/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.488Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java-Unsupported-major-minor-version-52-0错误解决"><a href="#java-Unsupported-major-minor-version-52-0错误解决" class="headerlink" title="java-Unsupported major.minor version 52.0错误解决"></a>java-Unsupported major.minor version 52.0错误解决</h1><p>eclipse版本设置不对, 低版本不能兼容高版本</p>
<p>eclipse中:</p>
<ol>
<li>windows -&gt; preferences -&gt; java -&gt; Complier -&gt; 设为一致版本</li>
<li>windows -&gt; preferences -&gt; java -&gt; Installed JREs  -&gt; 设为一致版本</li>
<li>项目右键(或core包) -&gt; (properties)build path  -&gt; configure build path -&gt; java build path -&gt; libraries  -&gt;  设为一致版本</li>
<li>项目右键(或core包) -&gt; (properties) -&gt; java compiler -&gt;  设为一致版本</li>
<li>项目右键(或core包) -&gt; (properties) -&gt;project facets -&gt;  设为一致版本</li>
</ol>
<h2 id="相关解释"><a href="#相关解释" class="headerlink" title="相关解释"></a>相关解释</h2><p>complier 是全局的解析<br>installed jres 可以理解为全局常量, 有些设置会直接默认这个常量, 如项目的jdk<br>build path 单独某个项目的运行环境<br>java compiler : 单独某个项目的编译环境<br>project facets: eclipse(其他Ide)的配套组件</p>
<h2 id="build-path-和complier-的区别"><a href="#build-path-和complier-的区别" class="headerlink" title="build path 和complier 的区别:"></a>build path 和complier 的区别:</h2><ul>
<li>build path 是运行环境</li>
<li>compiler是提示报错信息和编译时的jdk版本</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/02/JAVA-MVC各层命名规则-对象术语/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/02/JAVA-MVC各层命名规则-对象术语/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-02T04:19:08.473Z">
          2018-05-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="JAVA-MVC各层命名规则-对象术语"><a href="#JAVA-MVC各层命名规则-对象术语" class="headerlink" title="JAVA-MVC各层命名规则-对象术语"></a>JAVA-MVC各层命名规则-对象术语</h1><ul>
<li>DAO (data access object) 数据库访问对象<br>访问数据库的</li>
<li>DTO (Data Transfer Object) 数据传输对象<br>DTO 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。注意，不要因实 现这些方法而导致 DTO 依赖于任何新类。在设计数据传输对象时，您有两种主要选择：使用一般集合；或使用显式的 getter 和 setter 方法创建自定义对象。<br>个人感觉是api类似那种的用法</li>
<li><p>DO (Domain Object) 领域对象<br>从现实世界中抽象出来的有形或无形的业务实体。<br>概念模型, 描述逻辑为基础, 可以包含行为和数据</p>
</li>
<li><p>BO (business object) 业务对象</p>
</li>
<li>POJO (plain ordinary java object) 简单无规则java对象</li>
<li>PO (persistant object) 持久对象<br>就是在Object/Relation Mapping框架中的Entity<br>接收数据库DAO层的(java bean???)</li>
<li>VO(value object/ view object) 值对象/表现层对象</li>
<li>TO  (Transfer Object) 传输对象  在应用程序不同 tie( 关系 ) 之间传输的对象</li>
</ul>
<p>JSP/HTML -&gt; VO -&gt; PO -&gt; DAO -&gt; DB -&gt; PO -&gt; BO -&gt; VO -&gt; JSP/HTML</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/4/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/6/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 whellote
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>