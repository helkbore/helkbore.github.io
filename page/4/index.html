<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 4 | Whellote</title>

  
  <meta name="author" content="whellote">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Whellote"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Whellote" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Whellote</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/java里的main方法/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/java里的main方法/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.839Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java里的main方法"><a href="#java里的main方法" class="headerlink" title="java里的main方法"></a>java里的main方法</h1><ul>
<li><p>形式<br>public static void main(String[] args){ }<br>public static void main(String args[]){ }</p>
<p>String[] args可以写成String args[]，以及args的名称可以改变外</p>
</li>
<li><p>eclips快速创建<br>输入<code>main</code>，在按住<code>Alt+/</code>的方式快速创建main方法。</p>
</li>
<li><p>static的定义是为了JVM在调用main方法时不用实例化对象，只需要在初始时加载main方法所在类，然后直接通过类名.main来调用main方法。</p>
</li>
<li>main的名称不能变是为了JVM能够识别程序运行的起点，main方法可以被重载，重载的main方法不会被执行。</li>
<li>非守护线程</li>
<li>main()方法中可以throw Exception</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/java-基础-集合框架/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/java-基础-集合框架/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.832Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java-基础-集合框架"><a href="#java-基础-集合框架" class="headerlink" title="java-基础-集合框架"></a>java-基础-集合框架</h1><h2 id="集合框架定义的接口"><a href="#集合框架定义的接口" class="headerlink" title="集合框架定义的接口"></a>集合框架定义的接口</h2><ul>
<li>Collection</li>
<li>List</li>
<li>Set</li>
<li>SortedSet</li>
<li>Map</li>
<li>Map.Entry</li>
<li>SortedMap</li>
<li>Enumeration</li>
</ul>
<h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>继承于Collection和一个 List实例存储一个有序集合的元素。</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul>
<li>继承于 Collection，是一个不包含重复元素的集合。</li>
</ul>
<h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><ul>
<li>继承于Set保存有序的集合。</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li>将唯一的键映射到值。</li>
</ul>
<h3 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h3><ul>
<li>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</li>
<li>由Map接口中声明的entrySet()方法返回一个包含映射条目的集。每个组元素都是一个Map.Entry对象。</li>
</ul>
<h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><ul>
<li>继承于Map，使Key保持在升序排列。</li>
</ul>
<h3 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h3><ul>
<li>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/java-基础-Vector与ArrayList区别/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/java-基础-Vector与ArrayList区别/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.821Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java-基础-Vector与ArrayList区别"><a href="#java-基础-Vector与ArrayList区别" class="headerlink" title="java-基础-Vector与ArrayList区别"></a>java-基础-Vector与ArrayList区别</h1><h2 id="List接口的三个实现类"><a href="#List接口的三个实现类" class="headerlink" title="List接口的三个实现类"></a>List接口的三个实现类</h2><ul>
<li>ArrayList</li>
<li>Vector</li>
<li>LinkedList</li>
</ul>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li>通过数组实现</li>
<li>缺点: 每个元素之间不能有间隔</li>
<li>存储空间扩容时需要将数据复制</li>
<li>能快速随机访问和遍历</li>
<li>不便于插入和删除</li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li>通过数组实现</li>
<li>支持线程同步(某一时刻只有一个线程能够写Vector)</li>
<li>访问比ArrayList慢</li>
<li>包含许多传统的方法, 这些方法不属于集合框架</li>
<li>主要用在事先不知道数组的大小, 或者只是需要一个可以改变大小的数组的情况</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li>链表</li>
<li>适合动态插入和删除</li>
<li>随机访问和遍历比较慢</li>
<li>具有List没有定义的方法: 操作表头和表尾元素</li>
<li>可以当做堆栈, 队列, 双向队列使用</li>
</ul>
<h2 id="超过长度时增长率"><a href="#超过长度时增长率" class="headerlink" title="超过长度时增长率"></a>超过长度时增长率</h2><p>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zhangzongle/p/5432212.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangzongle/p/5432212.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/java堆栈/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/java堆栈/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.810Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java堆栈"><a href="#java堆栈" class="headerlink" title="java堆栈"></a>java堆栈</h1><p>JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：</p>
<ol>
<li>寄存器</li>
<li>本地方法区</li>
<li>方法区</li>
<li>栈</li>
<li>堆</li>
</ol>
<h2 id="通用编译原理上的内存分配策略"><a href="#通用编译原理上的内存分配策略" class="headerlink" title="通用编译原理上的内存分配策略"></a>通用编译原理上的内存分配策略</h2><ol>
<li>静态</li>
<li>栈式</li>
<li>堆式</li>
</ol>
<h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p>编译时就确定存储空间的需求, 因此不允许有可变的无法准确计算存储空间的结构出现(可变数组, 嵌套或递归结构)</p>
<h3 id="栈式"><a href="#栈式" class="headerlink" title="栈式"></a>栈式</h3><ul>
<li>动态存储分配, 但是在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存</li>
<li>用来执行程序的</li>
<li>c/c++所有方法调用都是用栈, 通过指针, 速度最快</li>
<li>数据结构: 先进后出</li>
<li>操作系统: 由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈</li>
<li>缓存方式: 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。</li>
<li>申请影响: 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li>
<li>内存: 有栈顶地址和最大容量的连续的内存空间, 向低地址扩展</li>
</ul>
<h3 id="堆式"><a href="#堆式" class="headerlink" title="堆式"></a>堆式</h3><ul>
<li>堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配, 堆中的内存可以按照任意顺序分配和释放.</li>
<li>用来放对象的</li>
<li>堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间</li>
<li>面向对象的多态性, 堆是必不可少的.</li>
<li>数据结构: 队列优先, 先进先出/ 堆可以被看成是一棵树，如：堆排序。</li>
<li>操作系统: 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</li>
<li>缓存方式: 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</li>
<li>申请影响: 操作系统有一个空闲的内存地址链表, 当程序申请时, 会寻找第一个空间大于申请空间的堆节点分配给程序, 系统会将多余那部分重新放入空闲链表里</li>
<li>内存: 不连续的, 遍历是由低地址向高地址扩展</li>
</ul>
<h2 id="JVM中的堆栈"><a href="#JVM中的堆栈" class="headerlink" title="JVM中的堆栈"></a>JVM中的堆栈</h2><ul>
<li>JVM为每个新创建的线程都分配一个堆栈</li>
<li>堆栈以帧为单位保存线程的状态。</li>
<li>JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</li>
</ul>
<h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><ul>
<li>基础数据类型</li>
<li>局部变量</li>
<li>对象的引用变量</li>
<li>特点: 执行完毕立即释放</li>
</ul>
<h2 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h2><p>new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。</p>
<ul>
<li>new创建的对象和数组。</li>
<li>堆内存中所有的实体都有内存地址值。</li>
<li>堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。</li>
<li>堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除，这也是JAVA优于C++的表现之一（C++中需要程序员手动清除）。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>Car c = new Car(); // 将地址给了c<br>Car c2 = c // c 和 c2 都指向同一个 new Car() 内存地址</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ibelieve618/p/6380328.html" target="_blank" rel="noopener">https://www.cnblogs.com/ibelieve618/p/6380328.html</a><br><a href="http://blog.csdn.net/jerryao/article/details/874101" target="_blank" rel="noopener">http://blog.csdn.net/jerryao/article/details/874101</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/java包装类/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/java包装类/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.786Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java包装类"><a href="#java包装类" class="headerlink" title="java包装类"></a>java包装类</h1><h2 id="包装类简介"><a href="#包装类简介" class="headerlink" title="包装类简介"></a>包装类简介</h2><ul>
<li>为什么会有包装类?<br>  Java中的基本数据类型是不面向对象的, 变量是存在栈中的, 更高效<br>  变量的值存储在栈里，而对象存储在堆里，相比而言，堆栈更高效，这也是java保留基本类型的原因。</li>
<li>除了Integer和Character类以后，其它六个类的类名和基本数据类型一直，只是类名的第一个字母大写即可。<br>  Byte, Boolean, Short, Character, Integer, Long, Float, Double</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol>
<li>作为和基本数据类型对应的类类型存在，方便涉及到对象的操作。</li>
<li>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</li>
</ol>
<h3 id="掌握"><a href="#掌握" class="headerlink" title="掌握"></a>掌握</h3><ol>
<li>包装类与基础数据类型之间的转换</li>
<li>包装类的类型转换(包装类的常用方法)</li>
<li>开发中包装类的常见作用</li>
<li>自动拆装箱</li>
</ol>
<h3 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><ul>
<li>当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。</li>
<li>equals方法并不会进行类型转换</li>
</ul>
<h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><p>详见:<a href="http://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.csdn.net/hjf19790118/article/details/7081925" target="_blank" rel="noopener">http://blog.csdn.net/hjf19790118/article/details/7081925</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/java-Unsupported major.minor version 52.0错误解决-eclipse-jdk配置/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/java-Unsupported major.minor version 52.0错误解决-eclipse-jdk配置/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.767Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="java-Unsupported-major-minor-version-52-0错误解决"><a href="#java-Unsupported-major-minor-version-52-0错误解决" class="headerlink" title="java-Unsupported major.minor version 52.0错误解决"></a>java-Unsupported major.minor version 52.0错误解决</h1><p>eclipse版本设置不对, 低版本不能兼容高版本</p>
<p>eclipse中:</p>
<ol>
<li>windows -&gt; preferences -&gt; java -&gt; Complier -&gt; 设为一致版本</li>
<li>windows -&gt; preferences -&gt; java -&gt; Installed JREs  -&gt; 设为一致版本</li>
<li>项目右键(或core包) -&gt; (properties)build path  -&gt; configure build path -&gt; java build path -&gt; libraries  -&gt;  设为一致版本</li>
<li>项目右键(或core包) -&gt; (properties) -&gt; java compiler -&gt;  设为一致版本</li>
<li>项目右键(或core包) -&gt; (properties) -&gt;project facets -&gt;  设为一致版本</li>
</ol>
<h2 id="相关解释"><a href="#相关解释" class="headerlink" title="相关解释"></a>相关解释</h2><p>complier 是全局的解析<br>installed jres 可以理解为全局常量, 有些设置会直接默认这个常量, 如项目的jdk<br>build path 单独某个项目的运行环境<br>java compiler : 单独某个项目的编译环境<br>project facets: eclipse(其他Ide)的配套组件</p>
<h2 id="build-path-和complier-的区别"><a href="#build-path-和complier-的区别" class="headerlink" title="build path 和complier 的区别:"></a>build path 和complier 的区别:</h2><ul>
<li>build path 是运行环境</li>
<li>compiler是提示报错信息和编译时的jdk版本</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/JAVA-MVC各层命名规则-对象术语/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/JAVA-MVC各层命名规则-对象术语/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.756Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="JAVA-MVC各层命名规则-对象术语"><a href="#JAVA-MVC各层命名规则-对象术语" class="headerlink" title="JAVA-MVC各层命名规则-对象术语"></a>JAVA-MVC各层命名规则-对象术语</h1><ul>
<li>DAO (data access object) 数据库访问对象<br>访问数据库的</li>
<li>DTO (Data Transfer Object) 数据传输对象<br>DTO 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。注意，不要因实 现这些方法而导致 DTO 依赖于任何新类。在设计数据传输对象时，您有两种主要选择：使用一般集合；或使用显式的 getter 和 setter 方法创建自定义对象。<br>个人感觉是api类似那种的用法</li>
<li><p>DO (Domain Object) 领域对象<br>从现实世界中抽象出来的有形或无形的业务实体。<br>概念模型, 描述逻辑为基础, 可以包含行为和数据</p>
</li>
<li><p>BO (business object) 业务对象</p>
</li>
<li>POJO (plain ordinary java object) 简单无规则java对象</li>
<li>PO (persistant object) 持久对象<br>就是在Object/Relation Mapping框架中的Entity<br>接收数据库DAO层的(java bean???)</li>
<li>VO(value object/ view object) 值对象/表现层对象</li>
<li>TO  (Transfer Object) 传输对象  在应用程序不同 tie( 关系 ) 之间传输的对象</li>
</ul>
<p>JSP/HTML -&gt; VO -&gt; PO -&gt; DAO -&gt; DB -&gt; PO -&gt; BO -&gt; VO -&gt; JSP/HTML</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/IDEA配置jdk-tomcat-web项目-servlet/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/IDEA配置jdk-tomcat-web项目-servlet/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.743Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="IDEA配置jdk-tomcat-web项目-servlet"><a href="#IDEA配置jdk-tomcat-web项目-servlet" class="headerlink" title="IDEA配置jdk-tomcat-web项目-servlet"></a>IDEA配置jdk-tomcat-web项目-servlet</h1><hr>
<h2 id="简洁版顺序"><a href="#简洁版顺序" class="headerlink" title="简洁版顺序"></a>简洁版顺序</h2><ol>
<li>破解idea</li>
<li>原始窗口 configure -&gt; project defaults -&gt; Project Struture</li>
<li>原始窗口 configure -&gt; settings -&gt; Build, Execution, Deployment -&gt; Application Servers</li>
<li>新建project -&gt; 空project(选择jdk和project language level 为8) -&gt; 新建module 勾选web application -&gt; OK</li>
<li>Project Struture -&gt; facts -&gt; 添加web.xml 注意修改WEB-INF的路径保存</li>
<li>在文档结构里, WEB-INF下建classes和lib文件夹</li>
<li>在Project Struture -&gt; module -&gt; paths中将 User module compile output path 都设为classes目录</li>
<li>在Project Struture -&gt; module -&gt; dependencies -&gt; 选jdk, 右边加号 -&gt; 第一个 JARS or directories 确定后选 Jar Directory</li>
<li>因为是web项目所以也在这个界面添加 roject Struture -&gt; module -&gt; dependencies -&gt; +号 -&gt; Libraries -&gt; tomcat</li>
<li>配置tomcat: run -&gt; edit configurations -&gt; +号 -&gt; tomcat server -&gt; local -&gt; 给服务器命个名tomcat8.0.32 -&gt; 下边tomcat server settings 里勾选 deploy applications configured in Tomcat instance 和 Preserve sessions across restarts and redeploys</li>
<li>部署tomcat run -&gt; edit configurations -&gt; deployment -&gt; +号 -&gt; Artifacts -&gt; 右边 application context 写上 /module名, 我的是 /MyTest</li>
<li>修改index.jsp并运行</li>
<li>在src下建包建servlet, 打开该文件, 在doGet方法里添加 <code>response.sendRedirect(&quot;error.jsp&quot;);</code></li>
<li>在web目录下建一个error.jsp并编辑</li>
<li><p>修改web.xml配置servlet</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>TestServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>test.web.TestServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>TestServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译运行 地址为: localhost:8080/Module名/url-pattern中的地址<br>我这里对应的就是: localhost:8080/MyTest/test</p>
</li>
</ol>
<hr>
<h2 id="激活IDEA-见另一个文档"><a href="#激活IDEA-见另一个文档" class="headerlink" title="激活IDEA(见另一个文档)"></a>激活IDEA(见另一个文档)</h2><h2 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h2><ol>
<li>选择configure -&gt; project defaults -&gt; Project Struture(或者编辑器界面的file-&gt; project struture)<br><img src="img/1.png" alt="1"></li>
<li>点击sdks -&gt; 中间栏 加号, 选JDK </li>
<li>弹出一个对话框，让你去选择JDK安装的路径，选择好自己安装的JDK路径，点击OK即可。<br><img src="img/2.png" alt="1"></li>
</ol>
<h2 id="配置tomcat-可跳过-建完项目弄"><a href="#配置tomcat-可跳过-建完项目弄" class="headerlink" title="配置tomcat(可跳过, 建完项目弄)"></a>配置tomcat(可跳过, 建完项目弄)</h2><ol>
<li>原始界面(图1)中的configure -&gt; settings -&gt; Build, Execution, Deployment -&gt; Application Servers</li>
<li>点击中间栏的加号</li>
<li>在tomcat Home中选择安装好的tomcat -&gt; OK</li>
</ol>
<h2 id="创建web项目方法1"><a href="#创建web项目方法1" class="headerlink" title="创建web项目方法1"></a>创建web项目方法1</h2><ol>
<li>create new project (如果是编辑器界面则是: file -&gt; new project)</li>
<li>左边选择java, 右边project sdk选择对应的jdk, 下面点<br><img src="img/5.png" alt="1"></li>
<li>(此种方法也可以不建module,将project当做module用了)右键点击项目-&gt; new -&gt; module</li>
<li>勾选web application<br><img src="img/3.png" alt="1"></li>
</ol>
<h2 id="创建web项目方法2"><a href="#创建web项目方法2" class="headerlink" title="创建web项目方法2"></a>创建web项目方法2</h2><ol>
<li>create new project (如果是编辑器界面则是: file -&gt; new project)</li>
<li>左边选择Empty project -&gt; next -&gt; finish</li>
<li>建好project后会自动弹出一个建module的窗口</li>
<li>中间栏加号 -&gt; new module -&gt; java ee 的web application<br><img src="img/3.png" alt="1"></li>
<li>我的因为2017.3版本, 没法选择建web.xml和版本号要之后建</li>
<li>输入module名(IDEA里module意思是模块, 放在同一个project下, project类似于一个文件夹吧. 集合相关的模块, 这些模块也比较独立, 可以对应eclipse里的项目了) -&gt; OK</li>
</ol>
<h3 id="打开project-structure的两种方法"><a href="#打开project-structure的两种方法" class="headerlink" title="打开project structure的两种方法:"></a>打开project structure的两种方法:</h3><ol>
<li>File –&gt; Project Structure（快捷键ctrl+alt+shift+s）</li>
<li>Navigation Bar中的Project Structure按钮<br><img src="img/7.png" alt="1"></li>
<li>没有这个Navigation Bar可在View中勾选Navigation Bar</li>
</ol>
<h2 id="2017-3版本创建web项目无法自动生成web-xml"><a href="#2017-3版本创建web项目无法自动生成web-xml" class="headerlink" title="2017.3版本创建web项目无法自动生成web.xml"></a>2017.3版本创建web项目无法自动生成web.xml</h2><ol>
<li>FILE -&gt; project struture -&gt; 左边选fects</li>
<li>中间栏选中web(新建的module名) 右边deployment descriptors面板里 +号选择web.xml及版本. -&gt; OK</li>
<li>注意: 选择web.xml的位置时将web-inf放入web目录下</li>
</ol>
<p><img src="img/4.png" alt="1"></p>
<h2 id="idea文档结构"><a href="#idea文档结构" class="headerlink" title="idea文档结构"></a>idea文档结构</h2><ul>
<li>idea文件夹和webapp.iml是IDEA自动创建的, 包含了工程和模块的配置数据</li>
<li>.idea和.settings分别是intelliJ和eclipse的相关依赖</li>
<li>build目录是class文件输出路径，这一点默认和eclipse是一样的。</li>
<li>out目录是所谓artifact输出路径，即提供给tomcat的web程序目录，具体的web根目录就是下级的web_test_Web_explorded。</li>
<li>src文件夹是源码目录</li>
<li>web文件夹相当于eclipse创建的web工程WebContent文件夹，包含了WEB-INF/web.xml及index.jsp</li>
<li>External Libraries包含了JDK及Tomcat带的jsp-api、servlet-api jar文件</li>
</ul>
<h2 id="完善工程目录"><a href="#完善工程目录" class="headerlink" title="完善工程目录"></a>完善工程目录</h2><ol>
<li>(方法一)添加WEB-INF/lib目录(注意这时候web-inf和web还是平级的,一会改)<br>点击WEB-INF，右击New –&gt; Directory，directory name填写lib，拷贝项目所需的jar包到此目录，右击lib目录 –&gt; Add as Library<br><img src="img/6.png" alt="1"><br>这时会弹出Craete Library对话框，name填写lib即可，其它默认，点击OK确定<br>添加完成可在Project Structure中的Libraries中看到<br>注意：这种方法如果你不拷贝jar包到lib下，右击时是没有Add as Library选项的</li>
<li>(方法二)打开Project Structure –&gt; libraries -&gt; 点击+选择java –&gt; 在弹出的Select Library Files中在WEB-INF下创建lib目录选择并点击OK –&gt; 在弹出的Choose Categories of Selected Files中选择Jar Directory点击OK –&gt; 在弹出的Choose Modules中点击OK</li>
</ol>
<h2 id="添加conf目录用于添加配置文件"><a href="#添加conf目录用于添加配置文件" class="headerlink" title="添加conf目录用于添加配置文件"></a>添加conf目录用于添加配置文件</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3><ol>
<li>右击项目New –&gt; Directory –&gt; directory name填写conf，点击OK –&gt; </li>
<li>右击conf目录Mark Directory as –&gt; Sources Root</li>
<li>这样创建的conf source folder在Project Structure的Modules中可以看到</li>
</ol>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><ol>
<li>在Project Structure的左边Modules中, 右边sources 右击项目 –&gt; New Folder –&gt; Folder </li>
<li>name填conf，点击OK –&gt; </li>
<li>右击新建的conf –&gt; Sources –&gt; 点击底部的OK</li>
</ol>
<h2 id="配置classes和lib"><a href="#配置classes和lib" class="headerlink" title="配置classes和lib"></a>配置classes和lib</h2><h3 id="在web-inf下建classes和lib"><a href="#在web-inf下建classes和lib" class="headerlink" title="在web-inf下建classes和lib"></a>在web-inf下建classes和lib</h3><h3 id="配置文件夹路径"><a href="#配置文件夹路径" class="headerlink" title="配置文件夹路径"></a>配置文件夹路径</h3><ol>
<li>File -&gt; Project Structure (ctrl + shift + Alt + s) 或者使用工具栏的快捷键 -&gt; 选择Modules -&gt; 选择Paths -&gt; </li>
<li>选择“Use module compile out path” -&gt; 将Outputpath 和Test output path 都设置为刚刚创建的classes文件夹</li>
<li>选择当前窗口的Dependencies -&gt; 将Module SDK选择为1.6 -&gt;点击右边的 + 号 -&gt; 选择 “1 JARS or directories …”</li>
<li>选择刚刚创建的lib文件夹 -&gt; OK</li>
</ol>
<h2 id="引入tomcat包-后面建servlet"><a href="#引入tomcat包-后面建servlet" class="headerlink" title="引入tomcat包(后面建servlet)"></a>引入tomcat包(后面建servlet)</h2><p>File -&gt; Project Structure -&gt; Modules -&gt; 选择当前窗口的Dependencies -&gt; +号 -&gt; tomcat</p>
<h2 id="配置tomcat容器"><a href="#配置tomcat容器" class="headerlink" title="配置tomcat容器"></a>配置tomcat容器</h2><ol>
<li>打开菜单Run -&gt; Edit Configurations…</li>
<li>点击 “+” ，选择 “Tomcat Server” -&gt; 选择“Local”</li>
<li>在Name出输入新的服务器名，点击 “Application Server” 后面的 “Configure…”，弹出Application Servers窗口，在Tomcat Home 选择本地安装的tomcat目录 -&gt; OK(如果前面已经配置了tomcat这步略)</li>
<li>“Run/Debug Configurations”窗口中Name一栏输入服务器的名字tomcat7，在“Server”面板中，勾选取消“After Launch”，设置“HTTP port”和“JMX port”（默认值即可），</li>
<li>端口旁边的deploy applications configured in Tomcat instance 和 Preserve sessions across restarts and redeploys勾选上</li>
<li>点击Apply -&gt; OK，至此tomcat配置完毕（左边列表中tomcat图标上小红叉是未部署项目的提示，部署项目后就会消失）。</li>
</ol>
<h2 id="在tomcat上部署并运行项目"><a href="#在tomcat上部署并运行项目" class="headerlink" title="在tomcat上部署并运行项目"></a>在tomcat上部署并运行项目</h2><ol>
<li>在创建好tomcat后，可以通过工具栏快速打开tomcat的配置页面：<br>也可以通过菜单栏：Run -&gt; Edit Configurations… -&gt;<br><img src="img/7.png" alt="1"></li>
<li>选择刚创建的tomcat7 -&gt; 选择Deployment -&gt;点击右边的“ + ”号 -&gt; 选择 Artifact</li>
<li>选择web项目 -&gt; Application Context可以填“/module名”(也可以不填) -&gt; Apply </li>
<li>编辑index.jsp, 运行tomcat</li>
</ol>
<h2 id="建servlet"><a href="#建servlet" class="headerlink" title="建servlet"></a>建servlet</h2><ol>
<li>右键src -&gt; new -&gt; servlet </li>
<li>输入servlet名字, 包名</li>
<li><p>打开servlet, 在doGet方法里写一个简单的跳转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"error.jsp"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改web.xml. 在web-app里添加</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>TestServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>test.web.TestServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>TestServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译运行 地址为: localhost:8080/Module名/url-pattern中的地址<br>我这里对应的就是: localhost:8080/MyTest/test</p>
</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/haroopad代码高亮代码/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/haroopad代码高亮代码/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.723Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="haroopad代码高亮对照表"><a href="#haroopad代码高亮对照表" class="headerlink" title="haroopad代码高亮对照表"></a>haroopad代码高亮对照表</h1><table>
<thead>
<tr>
<th>Language</th>
<th>key</th>
</tr>
</thead>
<tbody>
<tr>
<td>css</td>
<td>css</td>
</tr>
<tr>
<td>Dos.bat</td>
<td>dos</td>
</tr>
<tr>
<td>HTTP</td>
<td>http</td>
</tr>
<tr>
<td> Java</td>
<td>java</td>
</tr>
<tr>
<td> JavaScript</td>
<td>javascript</td>
</tr>
<tr>
<td> JSON j</td>
<td>son</td>
</tr>
<tr>
<td>php</td>
<td>php</td>
</tr>
<tr>
<td>python</td>
<td>python</td>
</tr>
<tr>
<td>SQL</td>
<td>sql</td>
</tr>
<tr>
<td>Vim Script</td>
<td>vim</td>
</tr>
<tr>
<td>xml, html</td>
<td>xml</td>
</tr>
</tbody>
</table>
<p>`</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>key</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bash</td>
<td>bash</td>
</tr>
<tr>
<td>c++</td>
<td>cpp</td>
</tr>
<tr>
<td>c#</td>
<td>cs</td>
</tr>
<tr>
<td>css</td>
<td>css</td>
</tr>
<tr>
<td>delphi</td>
<td>delphi</td>
</tr>
<tr>
<td>Django</td>
<td>django</td>
</tr>
<tr>
<td>Dos.bat</td>
<td>dos</td>
</tr>
<tr>
<td>Go</td>
<td>go</td>
</tr>
<tr>
<td> HTTP</td>
<td>http</td>
</tr>
<tr>
<td> Java</td>
<td>java</td>
</tr>
<tr>
<td> JavaScript</td>
<td>javascript</td>
</tr>
<tr>
<td> JSON j</td>
<td>son</td>
</tr>
<tr>
<td> lESS</td>
<td>less</td>
</tr>
<tr>
<td> lisp</td>
<td>lisp</td>
</tr>
<tr>
<td>Lua</td>
<td>lua</td>
</tr>
<tr>
<td>nginx</td>
<td>nginx</td>
</tr>
<tr>
<td>objective C</td>
<td>objectivec</td>
</tr>
<tr>
<td>Perl</td>
<td>perl</td>
</tr>
<tr>
<td>php</td>
<td>php</td>
</tr>
<tr>
<td>python</td>
<td>python</td>
</tr>
<tr>
<td>R</td>
<td>r</td>
</tr>
<tr>
<td>ruby</td>
<td>ruby</td>
</tr>
<tr>
<td>scala</td>
<td>scala</td>
</tr>
<tr>
<td>SQL</td>
<td>sql</td>
</tr>
<tr>
<td>Vim Script</td>
<td>vim</td>
</tr>
<tr>
<td>xml, html</td>
<td>xml</td>
</tr>
</tbody>
</table>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/15/git配置/"><span></span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/15/git配置/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-15T12:53:20.716Z">
          2018-04-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h1><ol>
<li>下载git</li>
<li>安装</li>
<li><p>本地设置的git文件夹(自己建, 应为本地仓库的位置)右键进入git bash输入账号密码用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;helkbore&quot;</span><br><span class="line">git config --global user.email &quot;helkbore@163.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SSH KEY</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;helkbore@163.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在系统用户的主目录下找到.ssh文件夹(我的是在C:\Users\whell)里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件</p>
</li>
<li>登陆GitHub，(点击头像 -&gt; settings 左边选择SSH and GPG keys)打开“Account settings”，“SSH Keys”页面：</li>
<li>点“Add SSH Key”/ new SSH，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</li>
<li><p>回到git bash, 把远程的仓库拉下来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:helkbore/mycode.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看远程分支, checkout出dev分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br><span class="line">git checkout origin/dev</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/3/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/5/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 whellote
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>